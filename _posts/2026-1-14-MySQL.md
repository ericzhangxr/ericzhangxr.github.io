---
layout: post
title: "An Inro of MySQL"
categories: 教程
---

# MySQL

quick sheet

https://github.com/codebasics/DataAnalysisProjects

```mysql
SELECT    -- 1. 你想要哪几列？ (What)
FROM      -- 2. 数据在哪个表里？ (Where)
WHERE     -- 3. 过滤条件是什么？ (Filter)
GROUP BY  -- 4. 怎么分组/分类？ (Aggregation)
HAVING    -- 5. 分组后还要再过滤吗？ (Filter after Aggregation)
ORDER BY  -- 6. 结果怎么排序？ (Sort)
```

How it works?

### SELECT

```mysql
select *
select column1, column2
select table.column #select from anothe table, column
select distinct #remove duplicate rows
```

also, there are some aggregateFunction can be used when you want to get some 'aggregated data'

due to the order of introduction, we don't use conditions in this chapter

``` mysql
#for example, if you have a table named sales, and you want to calculate the total salesrev in this table
select sum(salesrev) from sales;
#if you want to calculate the average salerev similarly
select avg(salesrev) from sales;
#NOTICE: IF NO CONDITION USED, SUCH METHOD IS CALCULATING A STATISTICAL VALUE OF SPECIFIC COLUMN
min()
max()
```

the aggregate function will reveal its charm in the following chapter

### FROM 

```mysql
from tablename
from tablename as alias # assign another name for convenience, as can be omit
select m.name m.level from members m;
```

From, also can be used to join two table 

```mysql
select m.name, o.amount
from members m
left join orders o
on m.id = o.member_id;
#on <condition_of_join>
```

**left join**, append the right table to the left table, all the left table is remained in the action, and the condition of join is important of the action.

### WHERE

WHERE is the first filter in your selection, similarly as Excel, it dropout the row which do not satisfied the condition

```mysql
select * from transactions where sales_amount > 1000;
#find the orders that sales amount larger than 1000
select * from transactions where market_code != 'mark001';
#find the market code NOT mark001
```

**between and**

```mysql
-- 找出 2020 年全年的订单
-- 等同于：order_date >= '2020-01-01' AND order_date <= '2020-12-31'
SELECT * FROM transactions WHERE order_date BETWEEN '2020-01-01' AND '2020-12-31';
```

```mysql
-- 只要 巴黎、伦敦、纽约 这三个城市的单子
SELECT * FROM transactions WHERE market_code IN ('Paris', 'London', 'New York');
```

**pattern matching**

%	represents any number of characters (0 or countless). 
_	  represents any single character.

```mysql
-- 找出所有姓 "张" 的客户 (ZhangSan, ZhangWei...)
SELECT * FROM customers WHERE cust_name LIKE 'Zhang%';

-- 找出名字里包含 "Tech" 的公司 (HighTech, TechSoft...)
SELECT * FROM customers WHERE cust_name LIKE '%Tech%';
```

**is null selection**

```mysql
-- 找出还没有填写区域(zone)的记录
-- 错误写法：WHERE zone = NULL (这是错的！)
-- 正确写法：
SELECT * FROM markets WHERE zone IS NULL;
```

**AND OR NOT**

```MYSQL
-- 既要是2020年，又要金额大于500
WHERE year = 2020 AND sales_amount > 500

-- 要么是巴黎的单子，要么金额特别大
WHERE market_code = 'Paris' OR sales_amount > 100000

-- 不要巴黎的单子
WHERE NOT market_code = 'Paris'
```

**difference between where and having**

where deals with raw data, having deals with aggregated data

### GROUP BY

function as Pivot Table in excel

```mysql
SELECT
    分组列,              -- 1. 你按什么分的组？
    聚合函数(统计列)      -- 2. 分组后你要算什么？
FROM 表名
WHERE 过滤条件           -- (可选) 分组前先筛掉脏数据
GROUP BY 分组列;         -- 3. 告诉数据库按这一列合并
#a simple count of rows group by type
select customer_type, count(*) from customers group by customer_type;

#multi-group, aggregate the sales_qty
select product_code, customer_code, sum(sales_qty) from transactions group by product_code, customer_code;
```

NOTICE

```mysql
-- 错误！数据库会懵：一班有张三和王五两个人，你让我显示"name"，我到底显示谁的名字？
SELECT class, name, AVG(score)
FROM students
GROUP BY class;

#CORRECT CODE
-- 要么把 name 去掉
SELECT class, AVG(score) FROM students GROUP BY class;

-- 要么把 name 也加入分组（那就是按“班级+姓名”统计）
SELECT class, name, AVG(score) FROM students GROUP BY class, name;
```

### HAVING

HAVING must follow GROUP BY and precede ORDER BY

```mysql
SELECT
    分组列,
    聚合函数(统计列)
FROM 表名
WHERE 原始数据过滤条件      -- 第一关：筛掉不合格的行
GROUP BY 分组列             -- 第二关：打包分组
HAVING 聚合函数(统计列) 条件 -- 第三关：筛掉不合格的组
ORDER BY ...;
```

HAVING is a filter based on statistical values

```mysql
-- 老板想知道哪些客户的累计购买金额 超过了 100,000？
# 识别统计量：累计购买金额
sum(sales_amount) > 100000
# 识别调出列
select customer_code, sum(sales_amount) as total_amount from transactions group by customer_code having sum(sales_amount) > 100000
```

```mysql
select product_code, count(*) as number_of_transaction from transactions group by product_code having count(*) < 3;
-- 老板想找出哪些产品 (product_code) 的交易记录次数少于 2 次（可能是冷门产品，或者数据录入太少）。
```

```mysql
select market_code, sum(sales_qty) as total_qty from transactions where order_date like '2018%' group by market_code having sum(sales_qty) > 500;
-- 老板只想看 2018年 (order_date 是 2018) 的数据中，哪些市场 (market_code) 的总销量 (sales_qty) 超过了 500？
```

| **特性**             | **WHERE**                                                | **HAVING**                                                   |
| -------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| **操作对象**         | **每一行原始数据**                                       | **打包后的“组”**                                             |
| **例子**             | `WHERE sales_amount > 100`   (筛出金额大于100的单笔交易) | `HAVING SUM(sales_amount) > 100`   (筛出总金额大于100的客户/市场) |
| **能否用 SUM/COUNT** | **绝对不能**                                             | **必须配合使用** (通常)                                      |
| **执行时机**         | 分组之前 (Before Grouping)                               | 分组之后 (After Grouping)                                    |

As long as your filtering conditions include words like "in total", "average", or "how many times in total", must use HAVING.

### ORDER BY 



## The objects MySQL faced

apparently, is excel, dataframe, table, etc.

the variable is a string, represent the dataframe, the table, the column, or the row

## commands in the shell

```mysql
net start mysql80 #start the local server
net stop mysql80 #stop the local server
```

## A simple HELLO WORLD

IN mysql, a database should be created before everything

```mysql
SHOW DATABASES; #check the databases
CREATE DATABASE test; #create one
USE test; #CHOOSE THE DATABASES
```

the database test, is equivalently to .xlsx, then you can create some table, similar to table in the excel

```mysql
CREATE TABLE employees (
    id INT,              -- 整数类型
    name VARCHAR(50),    -- 字符串类型 (最多50个字符)
    dept VARCHAR(20),    -- 部门
    salary INT           -- 薪资
);
```

# MySQL workbench

![image-20260115170125239](./../assets/images/image-20260115170125239.png)

B-binary

UN-unsigned

ZF-zero fill, such as the length is 3 but  the value of the column is 5, the actual value in this cell is 005

AI- auto increment, 1,2,3,...,

G-generated column, which mean that this column is calculated by other columns

# SalesInsights

import database

https://github.com/codebasics/DataAnalysisProjects

open a query shell, first execute

```mysql
Use sales;
```

