---
layout: post
title: "An Inro of MySQL"
categories: 教程
---

# MYSQL

## MySQL BASIC GRAMMAR

quick sheet

https://github.com/codebasics/DataAnalysisProjects

```sql
SELECT    -- 1. 你想要哪几列？ (What)
FROM      -- 2. 数据在哪个表里？ (Where)
WHERE     -- 3. 过滤条件是什么？ (Filter)
GROUP BY  -- 4. 怎么分组/分类？ (Aggregation)
HAVING    -- 5. 分组后还要再过滤吗？ (Filter after Aggregation)
ORDER BY  -- 6. 结果怎么排序？ (Sort)
LIMIT	  -- 7. 只想查看一些结果而不是全部的
```

How it works?

### SELECT

```sql
select *
select column1, column2
select table.column #select from anothe table, column
select distinct #remove duplicate rows
```

also, there are some aggregateFunction can be used when you want to get some 'aggregated data'

due to the order of introduction, we don't use conditions in this chapter

``` sql
#for example, if you have a table named sales, and you want to calculate the total salesrev in this table
select sum(salesrev) from sales;
#if you want to calculate the average salerev similarly
select avg(salesrev) from sales;
#NOTICE: IF NO CONDITION USED, SUCH METHOD IS CALCULATING A STATISTICAL VALUE OF SPECIFIC COLUMN
min()
max()
```

the aggregate function will reveal its charm in the following chapter

### FROM 

```sql
from tablename
from tablename as alias # assign another name for convenience, as can be omit
select m.name m.level from members m;
```

From, also can be used to join two table 

```sql
select m.name, o.amount
from members m
left join orders o
on m.id = o.member_id;
#on <condition_of_join>
```

**left join**, append the right table to the left table, all the left table is remained in the action, and the condition of join is important of the action.

### WHERE

WHERE is the first filter in your selection, similarly as Excel, it dropout the row which do not satisfied the condition

```sql
select * from transactions where sales_amount > 1000;
#find the orders that sales amount larger than 1000
select * from transactions where market_code != 'mark001';
#find the market code NOT mark001
```

**between and**

```sql
-- 找出 2020 年全年的订单
-- 等同于：order_date >= '2020-01-01' AND order_date <= '2020-12-31'
SELECT * FROM transactions WHERE order_date BETWEEN '2020-01-01' AND '2020-12-31';
```

```sql
-- 只要 巴黎、伦敦、纽约 这三个城市的单子
SELECT * FROM transactions WHERE market_code IN ('Paris', 'London', 'New York');
```

**pattern matching**

%	represents any number of characters (0 or countless). 
_	  represents any single character.

```sql
-- 找出所有姓 "张" 的客户 (ZhangSan, ZhangWei...)
SELECT * FROM customers WHERE cust_name LIKE 'Zhang%';

-- 找出名字里包含 "Tech" 的公司 (HighTech, TechSoft...)
SELECT * FROM customers WHERE cust_name LIKE '%Tech%';
```

**is null selection**

```sql
-- 找出还没有填写区域(zone)的记录
-- 错误写法：WHERE zone = NULL (这是错的！)
-- 正确写法：
SELECT * FROM markets WHERE zone IS NULL;
```

**AND OR NOT**

```sql
-- 既要是2020年，又要金额大于500
WHERE year = 2020 AND sales_amount > 500

-- 要么是巴黎的单子，要么金额特别大
WHERE market_code = 'Paris' OR sales_amount > 100000

-- 不要巴黎的单子
WHERE NOT market_code = 'Paris'
```

**difference between where and having**

where deals with raw data, having deals with aggregated data

### GROUP BY

function as Pivot Table in excel

```sql
SELECT
    分组列,              -- 1. 你按什么分的组？
    聚合函数(统计列)      -- 2. 分组后你要算什么？
FROM 表名
WHERE 过滤条件           -- (可选) 分组前先筛掉脏数据
GROUP BY 分组列;         -- 3. 告诉数据库按这一列合并
#a simple count of rows group by type
select customer_type, count(*) from customers group by customer_type;

#multi-group, aggregate the sales_qty
select product_code, customer_code, sum(sales_qty) from transactions group by product_code, customer_code;
```

NOTICE

```sql
-- 错误！数据库会懵：一班有张三和王五两个人，你让我显示"name"，我到底显示谁的名字？
SELECT class, name, AVG(score)
FROM students
GROUP BY class;

#CORRECT CODE
-- 要么把 name 去掉
SELECT class, AVG(score) FROM students GROUP BY class;

-- 要么把 name 也加入分组（那就是按“班级+姓名”统计）
SELECT class, name, AVG(score) FROM students GROUP BY class, name;
```

### HAVING

HAVING must follow GROUP BY and precede ORDER BY

```sql
SELECT
    分组列,
    聚合函数(统计列)
FROM 表名
WHERE 原始数据过滤条件      -- 第一关：筛掉不合格的行
GROUP BY 分组列             -- 第二关：打包分组
HAVING 聚合函数(统计列) 条件 -- 第三关：筛掉不合格的组
ORDER BY ...;
```

HAVING is a filter based on statistical values

```sql
-- 老板想知道哪些客户的累计购买金额 超过了 100,000？
# 识别统计量：累计购买金额
sum(sales_amount) > 100000
# 识别调出列
select customer_code, sum(sales_amount) as total_amount from transactions group by customer_code having sum(sales_amount) > 100000
```

```sql
select product_code, count(*) as number_of_transaction from transactions group by product_code having count(*) < 3;
-- 老板想找出哪些产品 (product_code) 的交易记录次数少于 2 次（可能是冷门产品，或者数据录入太少）。
```

```sql
select market_code, sum(sales_qty) as total_qty from transactions where order_date like '2018%' group by market_code having sum(sales_qty) > 500;
-- 老板只想看 2018年 (order_date 是 2018) 的数据中，哪些市场 (market_code) 的总销量 (sales_qty) 超过了 500？
```

| **特性**             | **WHERE**                                                | **HAVING**                                                   |
| -------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| **操作对象**         | **每一行原始数据**                                       | **打包后的“组”**                                             |
| **例子**             | `WHERE sales_amount > 100`   (筛出金额大于100的单笔交易) | `HAVING SUM(sales_amount) > 100`   (筛出总金额大于100的客户/市场) |
| **能否用 SUM/COUNT** | **绝对不能**                                             | **必须配合使用** (通常)                                      |
| **执行时机**         | 分组之前 (Before Grouping)                               | 分组之后 (After Grouping)                                    |

As long as your filtering conditions include words like "in total", "average", or "how many times in total", must use HAVING.

### ORDER BY 

```sql
SELECT 列名
FROM 表名
... (WHERE / GROUP BY / HAVING)
ORDER BY 排序列名 [ASC | DESC];
# Ascending
# Descending
```

usage

```sql
select * from transactions order by sales_amount desc limit 5;
# only show 5 outcomes
```

multi order

 first sort the orders by "market_code"; if the markets are the same, then sort them by "sales_amount" from highest to lowest.

```sql
select * from transactions order by market_code desc, sales_amount desc;
```

the 6 highest sales_amount of the region?

```sql
select market_code, sum(sales_amount) as total_sales
from transactions
group by market_code
order by total_sales desc
limit 6;
```

## MYSQL ADVANCED GRAMMAR

### RANK

`RANK()` is used to assign a ranking (starting from 1) to each row in the query result, and it also handles "ties": 

- **Equal scores (parallel ranking) result in the same ranking position**
- **Ranking numbers jump (with gaps)**: For example, if two people tie for 2nd place, then the next one would be 4th place.
This is the most distinctive feature of `RANK()`: **with gaps** (gaps).

```sql
RANK() OVER (
  [PARTITION BY 分组列1, 分组列2, ...]
  ORDER BY 排序列1 [ASC|DESC], 排序列2 ...
)

-- NOTICE: rank() generated a new column in the table
```

**PARTITION BY** which is a group, and rank them in this group

e.g., according to user_id, rank the sales_mount

```sql
select *,
rank() over(
	partition by customer_code
    order by sales_amount desc
) as rk
from transactions;
```

but, if you want to get the largest order of one customer, you can 

```sql
select *
from(
	select *,
	row_number() over(
		partition by customer_code
    	order by sales_amount desc
	) as rk
	from transactions
) t -- NOTICE ALIAS MUST BE ASIGNED
where rk = 1;
```



For example, you want to select the full table of transaction, and ranked by the sales_amount

```sql
select *,
rank() over(order by sales_amount desc) as rk
from transactions;
```

| 需求                           | 用哪个         | 原因          |
| ------------------------------ | -------------- | ------------- |
| 比赛名次 / 排行榜（允许空档）  | `RANK()`       | 并列 → 跳号   |
| 分层 / 等级 / 档位（不想跳号） | `DENSE_RANK()` | 并列 → 不跳号 |
| 每行唯一 / 最新一条 / Top1     | `ROW_NUMBER()` | 不允许并列    |

## The objects MySQL faced

apparently, is excel, dataframe, table, etc.

the variable is a string, represent the dataframe, the table, the column, or the row

## commands in the shell

```sql
net start mysql80 #start the local server
net stop mysql80 #stop the local server
```

## A simple HELLO WORLD

IN mysql, a database should be created before everything

```sql
SHOW DATABASES; #check the databases
CREATE DATABASE test; #create one
USE test; #CHOOSE THE DATABASES
```

the database test, is equivalently to .xlsx, then you can create some table, similar to table in the excel

```sql
CREATE TABLE employees (
    id INT,              -- 整数类型
    name VARCHAR(50),    -- 字符串类型 (最多50个字符)
    dept VARCHAR(20),    -- 部门
    salary INT           -- 薪资
);
```

# MySQL workbench

![image-20260115170125239](./../assets/images/image-20260115170125239.png)

B-binary

UN-unsigned

ZF-zero fill, such as the length is 3 but  the value of the column is 5, the actual value in this cell is 005

AI- auto increment, 1,2,3,...,

G-generated column, which mean that this column is calculated by other columns

**Hint**

the default query of workbench is 1000 rows



# SalesInsights

import database

https://github.com/codebasics/DataAnalysisProjects

open a query shell, first execute

```sql
Use sales;
```

we have a table as

![image-20260116221359519](./../assets/images/image-20260116221359519.png)

ok, we want to show some advanced usage of sql

**The boss's request: "Don't just show me the total figures. I want to see the specific products that were sold in the top 2 orders in each market (market_code) based on the sales amount."**
