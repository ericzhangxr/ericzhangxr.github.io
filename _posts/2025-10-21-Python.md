---
layout: post
title: "Python"
categories: 教程
---

# Note of Python

# 一些前置知识

Python的索引是左闭右开的，同时是从0开始索引的


```python
for i in range(1,5):
    print(i)
print("-"*15)
a = [1,2,3,4]
print(a)
print(a[2])#实际上索引出来是第三个位置
print(a[1:3])
```

    1
    2
    3
    4
    ---------------
    [1, 2, 3, 4]
    3
    [2, 3]



```python
1302/42
```




    31.0



## Print的用法


```python
print("hello world")
```

    hello world



```python
a = 3
b = 4
print(a+b) #这个输出的是init
print(f"{a+b}") #这个输出的是字符串
```

    7
    7


f-string 对于其后的字符串中含有{}内的内容会自动求值

## Python的函数

函数  
什么是python的函数  
python的函数由def开始，后跟函数名，括号内为传入函数调用的参数  
中间是最后计算的过程  
return 后面的内容返回到调用函数的地方，具体可以看下面这个例子


```python
a = 3
b = 4
def function(a,b):
    return a+b+1
print(function(a,b)) #此处为第一个输出
c = function(a,b) + 1
print(c) #此处为第二个输出
print("计算的结果是",function(a,b)) #第三个输出
```

    8
    9
    计算的结果是 8


如果一个函数没有return的话，就是这样的


```python
def function2(a,b):
    c = a+b
print("without return",function2(a,b))
print(c)
```

    without return None
    9


## Python的类

class


```python
class Dog:
    def __init__(self,name,color):#声明一个类之后，需要用__init__定义这个类，其中self是必选项，用来代指这个类本身
        self.name = name #此处给出对应的索引的返回值，self.name表示这个方法，=后面的值表示这个方法返回的值
        self.color = color

    def bark(self):
        print(f"{self.name}正在狗叫")

dog1 = Dog("ctl","黑色")
dog2 = Dog("smx","白色")
print(f"{dog1.name}","这条狗的颜色是",f"{dog1.color}")
dog2.bark()#在调用自定义的方法时，需要加括号
```

    ctl 这条狗的颜色是 黑色
    smx正在狗叫


| 术语             | 含义                                 | 示例             |
| ---------------- | ------------------------------------ | ---------------- |
| 类 (Class)       | 模板或蓝图，定义了对象的属性和方法。 | `class Dog:`     |
| 对象 (Object)    | 根据类创建的实体，拥有具体的属性值。 | `dog1`           |
| 属性 (Attribute) | 对象的特征/状态。                    | `dog1.name`      |
| 方法 (Method)    | 对象的行为/功能。                    | `dog1.bark()`    |
| __init__         | 构造方法，用于初始化对象。           | 设置 `self.name` |


```python
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
class Employee:
   '所有员工的基类'
   empCount = 0
 
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
       print("Total Employee %d" % Employee.empCount)
 
   def displayEmployee(self):
       print("Name : ", self.name,  ", Salary: ", self.salary)

#此时这个类就写完了，下面创建这个类的实例
employee1 = Employee("alex",1000)
employee2 = Employee("steve",2000)

#如果我想访问他的薪水
print(employee1.salary)
print(employee2.salary)

#当然也可以通过我们写的函数
employee1.displayEmployee()

#如果是count呢？
employee1.displayCount()
employee2.displayCount()
```

    1000
    2000
    Name :  alex , Salary:  1000
    Total Employee 2
    Total Employee 2



```python
employee1.salary = 1500
employee1.displayEmployee()
```

    Name :  alex , Salary:  1500


### 类变量  

上述例子中的empCount在一个类中，但是在任何一个方法之外，这使得其成为一个类变量  
在每次创建一个新的用户时，都会调用主函数__init__执行一次，这使得empCount可以工作


```python
class Parent:        # 定义父类
    parentAttr = 100 #父类的类变量
    
    def __init__(self): #主函数
        print("调用父类构造函数")
    
    def parentMethod(self):
        print('调用父类方法')
    
    def setAttr(self, attr):
        Parent.parentAttr = attr #此处没有使用self.访问而是直接使用类名进行访问，说明这个方法改变的parentAttr是类属性。
    
    def getAttr(self):
        print("父类属性 :", Parent.parentAttr)

#——————————————子类

class Child(Parent):
    def __init__(self):
        print("调用了子类")
    def childmethod(self):
        print("调用了子类的方法")

c = Child()
c.childmethod()
c.parentMethod()
c.getAttr()
c.setAttr(200) #此处修改了类变量Parent的类属性Attr.
c.getAttr()
print("___________________________")
class Child2(Parent): 
    def setAttr(self, Attr):
        self.parentAttr = Attr #方法重写了

d = Child2() #此时创建了一个新的子类，他的方法重写了
d.getAttr()
d.setAttr(400) #由于此时子类时self.调用，这个parentAttr直接被子类创建了一个独属于这个子类的属性，而父类的类属性依旧不变
d.getAttr()
c.getAttr()
d.parentAttr #此时直接调用子类的这个属性，发现他被创建并改变成了400，但是父类的类属性依旧是200
```

    调用了子类
    调用了子类的方法
    调用父类方法
    父类属性 : 100
    父类属性 : 200
    ___________________________
    调用父类构造函数
    父类属性 : 200
    父类属性 : 200
    父类属性 : 200





    400



## 列表推导式

$$[\text{表达式} \quad \text{for} \quad \text{元素} \quad \text{in} \quad \text{可迭代对象}]$$

如果我想要批量生成一串带数字的字符串，可以这样生成


```python
base_string = "Argi"
string_list = [f"{base_string}_{i}" for i in range (1,11)]
print(string_list)
```

    ['Argi_1', 'Argi_2', 'Argi_3', 'Argi_4', 'Argi_5', 'Argi_6', 'Argi_7', 'Argi_8', 'Argi_9', 'Argi_10']


# re正则表达式

## 什么是正则表达式？

正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。

正则表达式可以在文本中查找、替换、提取和验证特定的模式。

## 基本符号

| 符号    | 含义                   | 示例                               |
| ------- | ---------------------- | ---------------------------------- |
| `.`     | 任意单个字符           | `c.t` 匹配 "cat"                   |
| `*`     | 0次或多次重复          | `wo*` → "w", "wo", "woo"           |
| `+`     | 1次或多次重复          | `go+` → "go", "goo"                |
| `?`     | 前面的内容可有可无     | `colou?r` → "color", "colour"      |
| `[]`    | 字符集合               | `[abc]` → a, b, c                  |
| `[0-9]` | 任意数字               | 匹配 0-9                           |
| `\d`    | 数字（等同于 `[0-9]`） | 匹配任何数字字符                   |
| `\w`    | 字母/数字/下划线       | 匹配 "hello_1" 等                  |
| `^`     | 开头                   | `^Hello` 匹配以 Hello 开头的字符串 |
| `$`     | 结尾                   | `world$` 匹配以 world 结尾的字符串 |

## 语法详解

- `runoo+b`，可以匹配 runoob、runooob、runoooooob 等，`+` 号代表前面的字符必须至少出现一次（1次或多次）
- `runoo*b`，可以匹配 runob、runoob、runoooooob 等，`*` 号代- 表前面的字符可以不出多次（0次、或只可以出现一次（0次或1次）
  re.match函数


```python
#!/usr/bin/python
# -*- coding: UTF-8 -*- 
#re.match()尝试的是从起始位置匹配一个模式，如果不是起始位置匹配成功，就返回none
import re
print(re.match('www', 'www.runoob.com').span())  # span返回的是匹配成功的位置
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配
```

    (0, 3)
    None



```python
#!/usr/bin/python
# -*- coding: UTF-8 -*- 
#re.search()是搜索字符串，并返回第一个成功的匹配
import re
print(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.search('com', 'www.runoob.com').span())         # 不在起始位置匹配
```

    (0, 3)
    (11, 14)



```python
#来一个复杂一点的
stri = "abs129dwuhia976ni"
m = re.search(r"(\d+)",stri)
m2 = re.search(r"(\d+).*?(\d+)",stri)
print(m.group())
print(m2.group()) #这里输出的是整个匹配到的模式
print(m2.group(1)) #group只包括了在源码中()中查找的内容
print(m2.group(2))
```

    129
    129dwuhia976
    129
    976


# 什么他妈的是装饰器？？？


```python
def hi(name="yasoob"):
    return "hi " + name
 
print(hi())
# output: 'hi yasoob'
 
# 我们甚至可以将一个函数赋值给一个变量，比如
greet = hi
# 我们这里没有在使用小括号，因为我们并不是在调用hi函数
# 而是在将它放在greet变量里头。我们尝试运行下这个
 
print(greet())
# output: 'hi yasoob'
 
# 如果我们删掉旧的hi函数，看看会发生什么！
del hi
print(hi())
#outputs: NameError
 
print(greet(),"2")
#outputs: 'hi yasoob'
```

    hi yasoob
    hi yasoob



    ---------------------------------------------------------------------------
    
    NameError                                 Traceback (most recent call last)
    
    Cell In[2], line 17
         13 # output: 'hi yasoob'
         14  
         15 # 如果我们删掉旧的hi函数，看看会发生什么！
         16 del hi
    ---> 17 print(hi())
         18 #outputs: NameError
         20 print(greet(),"2")


    NameError: name 'hi' is not defined



```python
print(greet())
```

    hi yasoob



```python
def hi(name="yasoob"):
    print("now you are inside the hi() function")
 
    def greet():
        return "now you are in the greet() function"
 
    def welcome():
        return "now you are in the welcome() function"
 
    print(greet())
    print(welcome())
    print("now you are back in the hi() function")
 
hi()
#output:now you are inside the hi() function
#       now you are in the greet() function
#       now you are in the welcome() function
#       now you are back in the hi() function
 
### 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。
# 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：
 
greet()
#outputs: NameError: name 'greet' is not defined
```

    now you are inside the hi() function
    now you are in the greet() function
    now you are in the welcome() function
    now you are back in the hi() function



    ---------------------------------------------------------------------------
    
    NameError                                 Traceback (most recent call last)
    
    Cell In[1], line 23
         14 hi()
         15 #output:now you are inside the hi() function
         16 #       now you are in the greet() function
         17 #       now you are in the welcome() function
       (...)
         20 # 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。
         21 # 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：
    ---> 23 greet()


    NameError: name 'greet' is not defined


从函数中返回函数


```python
def hi(name="yasoob"):
    def greet():
        return "now you are in the greet() function"
 
    def welcome():
        return "now you are in the welcome() function"
 
    if name == "yasoob":
        return greet
    else:
        return welcome
 
a = hi()
print(a)
#outputs: <function greet at 0x7f2143c01500>
 
#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数
#现在试试这个
 
print(a())
#outputs: now you are in the greet() function
```

    <function hi.<locals>.greet at 0x000001C17DEBA020>
    now you are in the greet() function


在 if/else 中返回 greet 而不是 greet()，是因为我们想返回**函数本身**，让调用者决定什么时候执行它，**而不是在返回时就立即执行**。


```python
def a_new_decorator(a_func):
 
    def wrapTheFunction():
        print("I am doing some boring work before executing a_func()")
 
        a_func()
 
        print("I am doing some boring work after executing a_func()")
 
    return wrapTheFunction
#上述函数定义了一个装饰器
def a_function_requiring_decoration():
    print("I am the function which needs some decoration to remove my foul smell")
#这是一个普通的函数
print('普通函数直接运行的结果')
a_function_requiring_decoration()
#outputs: "I am the function which needs some decoration to remove my foul smell"
print('普通函数应用了装饰器的结果')
a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
#now a_function_requiring_decoration is wrapped by wrapTheFunction()

a_function_requiring_decoration()
#outputs:I am doing some boring work before executing a_func()
#        I am the function which needs some decoration to remove my foul smell
#        I am doing some boring work after executing a_func()
```

    普通函数直接运行的结果
    I am the function which needs some decoration to remove my foul smell
    普通函数应用了装饰器的结果
    I am doing some boring work before executing a_func()
    I am the function which needs some decoration to remove my foul smell
    I am doing some boring work after executing a_func()


也就是说，这个普通的函数被作为一个参数传入了装饰器  
函数的执行逻辑是这样的，装饰器先执行装饰器中的内容，直到装饰器运行到了这个a_func后，再去执行了a_func，执行完毕后继续执行装饰器内的内容  
那么问题来了，@的形式是什么工作原理呢？？



```python
@a_new_decorator
def test_function():
    print('@ form of decoration')

print('This is the usage of @decorator')
test_function()
```

    This is the usage of @decorator
    I am doing some boring work before executing a_func()
    @ form of decoration
    I am doing some boring work after executing a_func()



```python
print(test_function.__name__)
```

    wrapTheFunction


functools.wraps 是一个用于保留被装饰函数元数据的装饰器工具函数。它的主要作用是让装饰器包装后的函数保持原有函数的名称、文档字符串、注解等属性。  
这个warp的作用就相当与吧a_func的__name__,还有__dox__,__module__全都复制到warpTheFunction中了


```python
from functools import wraps

def a_new_decorator(a_func):
    @wraps(a_func)  # 这里使用了 wraps
    def wrapTheFunction():
        print("I am doing some boring work before executing a_func()")
        a_func()
        print("I am doing some boring work after executing a_func()")
    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    """Hey yo! Decorate me!"""
    print("I am the function which needs some decoration to "
          "remove my foul smell")

print(a_function_requiring_decoration.__name__)
# Output: a_function_requiring_decoration
```

    a_function_requiring_decoration


# OS文件系统


```python
import os
os.getcwd()# 输出当前工作路径
```




    'D:\\Eric_Zhang\\PYproject'




```python
os.listdir() #列出当前目录下
os.listdir(os.path.join(os.getcwd(),'Cloud_word'))
```




    ['demo-python-jieba']



OK，所以最重要的其实是os.path.join()这个方法去拼接路径

os.path.exists(path): 判断文件或目录是否存在。

os.path.isfile(path) / os.path.isdir(path): 判断是否为文件或目录。

os.path.split(path): 将路径拆分为“目录”和“文件名”两部分。

os.path.splitext(path): 分离文件名和扩展名（常用于筛选文件类型，如只找 .ipynb 文件）。

os.mkdir(path): 创建单个目录。

os.makedirs(path): （推荐） 递归创建目录（例如 folder/sub_folder，如果父目录不存在会自动创建）。

os.rmdir(path): 删除空目录。

os.rename(src, dst): 重命名文件或移动文件。

os.remove(path): 删除指定的文件（不能删除目录）。

os.walk(top): （强大） 递归遍历目录树。它会生成目录中的文件名，适合批量处理深层文件夹中的文件。

# json格式

为什么要在python中使用json，json是一个非常强大，广泛的格式，因此在读取与储存中，尝尝可以通过将python的对象转化成json的格式，以便于对其他程序的适配。json的功能也是如此

## python对象&json字符串


```python
import json

data = {
    "name": "Alice",
    "age": 18,
    "scores": [95, 88, 92],
    "is_student": True
}

json_str = json.dumps(data)
print(json_str)
print(type(data))
print(type(json_str))
```

    {"name": "Alice", "age": 18, "scores": [95, 88, 92], "is_student": true}
    <class 'dict'>
    <class 'str'>


可以看到，通过`json.dumps()`操作，原本是dict的类型的数据转化成了符合标准json格式的字符串


```python
obj = json.loads(json_str)
print(obj)
print(obj["name"])
```

    {'name': 'Alice', 'age': 18, 'scores': [95, 88, 92], 'is_student': True}
    Alice


## 文件操作


```python
import json
data = {"x":1, "y":2}
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f, ensure_ascii=False, indent=4)
```

open 是上下文管理器，其语法是  
open(file,mode,encoding)  
file: 文件路径  

| 模式  | 含义                        |
| ----- | --------------------------- |
| `'r'` | 读取（默认）                |
| `'w'` | 写入（覆盖原文件）          |
| `'a'` | 追加写入（不会覆盖）        |
| `'b'` | 二进制模式（如读图片、MP3） |
| `'t'` | 文本模式（默认）            |
| `'+'` | 可读可写                    |


```python

```


```python
#with open("data.json", "a", encoding="utf-8") as f:
#    f.write("\n")#写入换行符
#    json.dump({"z": 3}, f, ensure_ascii=False, indent=4)#写入新的内容
with open("data.json", "r", encoding="utf-8") as f:
    data_dict = json.load(f)
#注意每次你执行这个代码块都会在原有的data.json文件后面添加一个新的{}]
print(data_dict)
print(type(data_dict))
#json.load()把这个json文件读取成了python的字典
```

    {'x': 1, 'y': 2}
    <class 'dict'>


# pandas

Intend to show the function of pandas better, we use a example datasheet named "example_data.xlsx" in currenr working directory


```python
import pandas as pd
file_name = "example_data.xlsx"
df = pd.read_excel(file_name)
df.head()
print(df)
#以上便是最基础的read_excel()的功能，就是读取一个表。
```

       number string  boolean
    0       1    two     True
    1       3   four    False


可选参数

| 参数       | 可选值        | 说明                                                         |
| ---------- | ------------- | ------------------------------------------------------------ |
| usecols    | "A:C"         | 读取A-C列                                                    |
| sheet_name | string or int | 读取特定名称或特定索引的表                                   |
| skiprows   | int           | 跳过几行，从int+1行开始读取                                  |
| nrows      | int           | 只读取int行                                                  |
| header     | None          | 这样设置的话，read_excel方法在读取excel时不会自动把第一行当成列名 |

一个简单的例子是，如果我只想读取example_data中的2-3行，B-C列，那我应该这样写


```python
df_2 = pd.read_excel(file_name,usecols="B:C",skiprows=1,nrows=2,header=None)
print(df_2)
print(df_2.columns)
#此时，由于在一开始设置header=None，默认的columns为自然数列，如何给他们设置我们想要的column值？
customColumn = ["number","bool"] #将这个property接受一个全是字符串的列表即可
df_3 = df_2
df_3.columns = customColumn
print(df_3.columns)
```

          1      2
    0   two   True
    1  four  False
    Index([1, 2], dtype='int64')
    Index(['number', 'bool'], dtype='object')


其他方法


```python
df.fillna(0) #将缺失值填充为0
df.shape 这个property返回一个二元数组
```




    (2, 3)



# 字符串处理


```python
a = "Hello"
b = "World"
c = a + " " + b #字符串拼接用+直接链接即可
print(c)
print(a[2]) #字符串索引
print(a[0:4]) #字符串切片

```

    Hello World
    l
    Hell



```python

```


```python

```



